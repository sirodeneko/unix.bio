import Layout from 'lib/components/layout'
import {} from '@geist-ui/react'

export const meta = {
  title: 'antsæºç è§£è¯»',
  date: '2021-03-13T16:47:51.655Z',
  description: 'antsæºç è§£è¯»',
  image: '/assets/image-20210314001412616.png',
}

[TOC]


## **ğŸ“– ç®€ä»‹**

â€‹		`ants`æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½çš„ goroutine æ± ï¼Œå®ç°äº†å¯¹å¤§è§„æ¨¡ goroutine çš„è°ƒåº¦ç®¡ç†ã€goroutine å¤ç”¨ï¼Œå…è®¸ä½¿ç”¨è€…åœ¨å¼€å‘å¹¶å‘ç¨‹åºçš„æ—¶å€™é™åˆ¶ goroutine æ•°é‡ï¼Œå¤ç”¨èµ„æºï¼Œè¾¾åˆ°æ›´é«˜æ•ˆæ‰§è¡Œä»»åŠ¡çš„æ•ˆæœã€‚

## ğŸ’¡ ä¸ºä»€ä¹ˆè¦ä½¿ç”¨goroutine æ± 

â€‹		Goè‡ªä»å‡ºç”Ÿå°±èº«å¸¦â€œé«˜å¹¶å‘â€çš„æ ‡ç­¾ï¼Œå…¶å¹¶å‘ç¼–ç¨‹å°±æ˜¯ç”±groutineå®ç°çš„ï¼Œå› å…¶æ¶ˆè€—èµ„æºä½ï¼Œæ€§èƒ½é«˜æ•ˆï¼Œå¼€å‘æˆæœ¬ä½çš„ç‰¹æ€§è€Œè¢«å¹¿æ³›åº”ç”¨åˆ°å„ç§åœºæ™¯ï¼Œä¾‹å¦‚æœåŠ¡ç«¯å¼€å‘ä¸­ä½¿ç”¨çš„HTTPæœåŠ¡,åœ¨golang [net/http](https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/master/src/net/http/server.go)åŒ…ä¸­,æ¯ä¸€ä¸ªè¢«ç›‘å¬åˆ°çš„tcpé“¾æ¥éƒ½æ˜¯ç”±ä¸€ä¸ªgroutineå»å®Œæˆå¤„ç†å…¶ä¸Šä¸‹æ–‡çš„ï¼Œç”±æ­¤ä½¿å¾—å…¶æ‹¥æœ‰æå…¶ä¼˜ç§€çš„å¹¶å‘é‡ååé‡ã€‚

â€‹		ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œgoroutineåœ¨æ“ä½œç³»ç»Ÿä¸Šåªè¦ä½ çš„ç¡¬ä»¶èµ„æºå¤Ÿå®ƒæ˜¯å¯ä»¥æ— é™å¯åŠ¨çš„ã€‚ä½†æ˜¯å¦‚æœå‡ºç°å¤§è§„æ¨¡çš„å¯åŠ¨goroutineçš„æƒ…å†µä¼šé€ æˆå¤§é‡å ç”¨ç³»ç»Ÿèµ„æºï¼Œæˆ‘ä»¬çŸ¥é“æ™®é€šçš„éƒ¨ç½²ä¸€ä¸ªgolangåº”ç”¨çš„æ—¶å€™æ“ä½œç³»ç»Ÿä¸ä»…ä»…ä¼šè¿è¡Œgolangç¨‹åºè¿˜æœ‰å…¶ä»–è¾…åŠ©çš„ç¨‹åºè¿è¡Œï¼Œæ‰€ä»¥ç†è®ºä¸Šè®²å·¥ä½œæ± çš„ç›®çš„å°±æ˜¯ä¸ºäº†é™åˆ¶golangçš„å¯åŠ¨æ•°é‡ï¼Œä¿è¯ä¸ä¼šå‡ºç°ç¡¬ä»¶è®¡ç®—èµ„æºæº¢å‡ºçš„æƒ…å†µã€‚

## ğŸ‘€ æºç è§£è¯»

### è¿è¡Œæµç¨‹

![](https://user-images.githubusercontent.com/7496278/66396519-7ed66e00-ea0c-11e9-9c1a-5ca54bbd61eb.png)

å¯ä»¥çœ‹å‡ºanstæ€»å…±åˆ†ä¸ºä¸¤å¤§æ¨¡å—`pool` å’Œ`worker`

`pool`ç”¨äºå­˜å‚¨`worker`ï¼Œ`worker`ç”¨äºæ‰§è¡Œä»»åŠ¡ã€‚

`pool`åˆ†ä¸ºæ™®é€šçš„`pool` å’Œ`pool_func`

`pool`å¯ä»¥å‘å…¶æäº¤ä¸åŒçš„func() æ¥æ‰§è¡Œä»»åŠ¡ï¼Œ

`pool_func`ï¼Œå…¶ åœ¨åˆå§‹åŒ–çš„æ—¶å€™è¦æä¾›ä¸€ä¸ª`func(interface{})`,æ­¤åæ¯æ¬¡æäº¤åªæäº¤å‚æ•°å³å¯ï¼Œantsä¼šè‡ªåŠ¨è¿è¡Œåˆå§‹åŒ–çš„å‡½æ•°ã€‚

#### options

`options`åŒ…ç”¨äºè®¾å®šæ± çš„ä¸€äº›å‚æ•°ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯`Option`æ˜¯`func(*Options)`æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œ`Options`æ‰æ˜¯ä¿å­˜æ± ä¿¡æ¯çš„ç»“æ„ä½“å˜é‡ã€‚

`Options`çš„ç»“æ„ä½“

```
type Options struct {
	//ExpiryDurationæ˜¯æ¸…é™¤ç¨‹åºgoroutineæ¸…ç†é‚£äº›è¿‡æœŸçš„ worker ç¨‹åºçš„æ—¶æœŸï¼Œ
	//æ¸…é™¤ç¨‹åºæ¯éš”`ExpiryDuration`æ‰«ææ‰€æœ‰ worker ï¼Œ4
	//å¹¶æ¸…ç†é‚£äº›æ²¡æœ‰è¢«ä½¿ç”¨è¶…è¿‡`ExpiryDuration`çš„ worker ã€‚
	//è¿™æ˜¯ä¸ºäº†é˜²æ­¢å¤§é‡çš„ä¸ä½¿ç”¨çš„workerè¿‡å¤šçš„å ç”¨å†…å­˜ï¼Œç¨‹åºåŠ¨æ€çš„è°ƒæ•´workerçš„æ•°é‡ 
	ExpiryDuration time.Duration
	
	// PreAllocæŒ‡ç¤ºåœ¨åˆå§‹åŒ–Poolæ—¶æ˜¯å¦å¯¹å†…å­˜è¿›è¡Œé¢„åˆ†é…
	PreAlloc bool
	
	// åœ¨pool.Submitä¸Šé˜»å¡goroutineçš„æœ€å¤§æ•°é‡ã€‚
	// 0ï¼ˆé»˜è®¤å€¼ï¼‰è¡¨ç¤ºæ²¡æœ‰æ­¤é™åˆ¶
	MaxBlockingTasks int
	
	// å½“Nonblockingä¸ºtrueæ—¶ï¼ŒPool.Submitå°†æ°¸è¿œä¸ä¼šè¢«é˜»å¡ã€‚
	// å½“æ— æ³•ä¸€æ¬¡å®ŒæˆPool.Submitæ—¶ï¼Œå°†è¿”å›ErrPoolOverloadã€‚
	// å½“Nonblockingä¸ºtrueæ—¶ï¼ŒMaxBlockingTasksä¸èµ·ä½œç”¨ã€‚
	Nonblocking bool
	
	// PanicHandlerç”¨äºå¤„ç†æ¯ä¸ªå·¥ä½œæµç¨‹ä¸­çš„Panicã€‚
	// å¦‚æœä¸ºnilï¼ŒPanicå°†å†æ¬¡ä»å·¥ä½œäººå‘˜goroutineä¸­æŠ›å‡ºã€‚
	PanicHandler func(interface{})
	
	// æ—¥å¿—æ¥å£
	Logger Logger
}
```

`options`åŒ…ä¸‹çš„å‡½æ•°éƒ½æ˜¯ç”¨äºè¿”å›ä¸€ä¸ª`Option`ç”¨äºè®¾å®š`Options` ï¼Œä¸åšè¿‡å¤šæè¿°ã€‚

#### pool

poolçš„ç»“æ„ä½“ï¼Œå…¶ç”¨æ¥è®°å½•poolçš„ä¸€äº›ä¿¡æ¯ï¼Œå¯é€šè¿‡ä¼ å…¥optionsæ¥è¿›è¡Œæ”¹å˜

```
type Pool struct {
	//æ± çš„å®¹é‡ï¼Œè´Ÿå€¼è¡¨ç¤ºæ± çš„å®¹é‡æ˜¯æ— é™çš„ï¼Œ
	capacity int32
	// runningæ˜¯å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineçš„æ•°é‡ã€‚
	running int32
	// workers is a slice that store the available workers.
	// å­˜å‚¨æäº¤çš„woeker
	workers workerArray
	// æ ‡ç¤ºpoolçš„çŠ¶æ€ï¼ˆå…³é—­æˆ–è€…æ‰“å¼€ï¼‰
	state int32
	// lock for synchronous operation.
	// sync.Lockerä¸ºä¸€ä¸ªğŸ”’æ¥å£ï¼Œéœ€è¦å®ç°å…¶Lockï¼ŒUnlockæ–¹æ³•
	lock sync.Locker
	// cond for waiting to get a idle worker.
	// ç”¨äºworkeræ‰§è¡Œè°ƒåº¦å…·ä½“ç”¨æ³•è§ https://ieevee.com/tech/2019/06/15/cond.html
	cond *sync.Cond
	// workerCacheåœ¨functionï¼šretrieveWorkerä¸­åŠ å¿«äº†å¯ç”¨workerçš„è·å–
	workerCache sync.Pool
	// blockingNumæ˜¯å·²åœ¨pool.blockä¸Šè¢«é˜»å¡çš„goroutineçš„æ•°é‡ï¼Œå—pool.lockä¿æŠ¤
	blockingNum int
	options *Options
}
```

##### NewPool åˆå§‹åŒ–å‡½æ•°

```
// NewPool generates an instance of ants pool.
func NewPool(size int, options ...Option) (*Pool, error) {
	// ä¼ å…¥å¤šä¸ªOptionç”¨äºè®¾å®šæ± çš„å‚æ•°ï¼Œè¿”å›ä¸€ä¸ªé…ç½®å®ä¾‹
	opts := loadOptions(options...)

	// æ± çš„å®¹é‡ï¼Œè´Ÿæ•°ä¸ºæ— é™å¤§
	if size <= 0 {
		size = -1
	}

	if expiry := opts.ExpiryDuration; expiry < 0 {
		// å¦‚æœæ‰«ææ—¶é—´å°äº0ï¼ŒæŠ›å‡ºé”™è¯¯
		return nil, ErrInvalidPoolExpiry
	} else if expiry == 0 {
		// å¦‚æœç­‰äº0ï¼ˆå³å¹¶æ²¡æœ‰è®¾å®šï¼‰é‡‡ç”¨é»˜è®¤å€¼1s
		opts.ExpiryDuration = DefaultCleanIntervalTime
	}

	if opts.Logger == nil {
		// å¦‚æœæ²¡æœ‰å®ç°æ—¥å¿—æ¥å£ï¼Œé‡‡ç”¨é»˜è®¤çš„æ—¥å¿—æ‰“å°å™¨
		opts.Logger = defaultLogger
	}

	// å®ä¾‹åŒ–ä¸€ä¸ªpoolå¯¹è±¡
	// lock ä¸ºinternalåŒ…ä¸‹å®ç°çš„ä¸€æŠŠè‡ªæ—‹ğŸ”’ï¼Œå®ç°è¾ƒç®€å•ï¼Œä¸åšè¡¨è¿°ã€‚
	p := &Pool{
		capacity: int32(size),
		lock:     internal.NewSpinLock(),
		options:  opts,
	}
	
	// åˆå§‹åŒ–ä¸€ä¸ª sync.Pool ï¼Œåˆ›å»ºå¯¹è±¡çš„å‡½æ•°
	// æ˜“çœ‹å‡º sync.Poolç¼“å­˜çš„æ˜¯ä¸€ä¸ªworker(ç»“æ„ä½“åä¸ºgoWorker)å¯¹è±¡ã€‚
	// workerä¸‹æ–‡è¿›è¡Œè§£é‡Š
	p.workerCache.New = func() interface{} {
		return &goWorker{
			pool: p,
			task: make(chan func(), workerChanCap),
		}
	}
	
	// å¦‚æœå¯¹å†…å­˜è¿›è¡Œé¢„åˆ†é…åˆ™é‡‡ç”¨é˜Ÿåˆ—çš„å½¢å¼è¿›è¡Œè°ƒåº¦ä¸ç„¶é‡‡ç”¨æ ˆçš„å½¢å¼
	// workerArrayä¸ºä¸€ä¸ªæ¥å£ï¼Œä¸åŒçš„å½¢å¼æœ‰ä¸åŒçš„æ–¹æ³•å®ç°
	// sizeä¼šé™åˆ¶workerArrayä¸­ç©ºé—²workeré˜Ÿåˆ—çš„é•¿åº¦ï¼Œè¿‡å°çš„é•¿åº¦ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜ï¼ˆæˆ‘è®¤ä¸ºï¼‰
	if p.options.PreAlloc {
		if size == -1 {
			return nil, ErrInvalidPreAllocSize
		}
		p.workers = newWorkerArray(loopQueueType, size)
	} else {
		p.workers = newWorkerArray(stackType, 0)
	}

	// å®ä¾‹åŒ–ä¸€ä¸ªcond
	p.cond = sync.NewCond(p.lock)

	// å¯åŠ¨goroutineå®šæœŸæ¸…ç†è¿‡æœŸçš„workerã€‚
	go p.purgePeriodically()

	return p, nil
}
```

åœ¨åˆå§‹åŒ–å‡½æ•°ä¸­ï¼Œåˆå§‹åŒ–äº†ä¸€ä¸ªpoolå¿…é¡»çš„èµ„æºï¼ŒåŒæ—¶å¯¹å…¶ç»‘å®šäº†ä¸åŒçš„è°ƒåº¦æ–¹æ³•ã€‚

##### purgePeriodically() å®šæœŸæ¸…ç†å‡½æ•°

```
func (p *Pool) purgePeriodically() {
	// å®šæ—¶å™¨ï¼Œæ¯éš”ExpiryDurationæ‰§è¡Œä¸€æ¬¡
	heartbeat := time.NewTicker(p.options.ExpiryDuration)
	defer heartbeat.Stop()

	for range heartbeat.C {
		// å¦‚æœæ± å·²å…³é—­ï¼Œè·³å‡ºæ¸…ç†å¾ªç¯
		if atomic.LoadInt32(&p.state) == CLOSED {
			break
		}
		
		
		p.lock.Lock()
		// è°ƒç”¨workerArrayçš„æ¸…ç†å‡½æ•°ï¼Œè¿”å›è¢«æ¸…ç†çš„å¯¹è±¡åˆ‡ç‰‡
		expiredWorkers := p.workers.retrieveExpiry(p.options.ExpiryDuration)
		p.lock.Unlock()

		//é€šçŸ¥è¿‡æ—¶çš„Workeråœæ­¢ã€‚ 
		//æ­¤é€šçŸ¥å¿…é¡»åœ¨p.lockä¹‹å¤–ï¼Œå› ä¸ºw.taskå¯èƒ½æ­£åœ¨é˜»å¡ï¼Œ
		//å¹¶ä¸”å¦‚æœè®¸å¤šWorkerä½äºéæœ¬åœ°CPUä¸Šï¼Œåˆ™å¯èƒ½ä¼šèŠ±è´¹å¤§é‡æ—¶é—´ã€‚
		for i := range expiredWorkers {
			expiredWorkers[i].task <- nil
			expiredWorkers[i] = nil
		}

		//å¯èƒ½ä¼šæ¸…ç†æ‰€æœ‰å·¥ä½œç¨‹åºï¼ˆæ²¡æœ‰ä»»ä½•å·¥ä½œç¨‹åºæ­£åœ¨è¿è¡Œï¼‰
		//æŸäº›è°ƒç”¨ç¨‹åºä»ç„¶å¡åœ¨â€œ p.cond.Waitï¼ˆï¼‰â€ä¸­ï¼Œ
		//åº”è¯¥å”¤é†’æ‰€æœ‰è¿™äº›è°ƒç”¨ç¨‹åº
		if p.Running() == 0 {
			p.cond.Broadcast()
		}
	}
}
```

å…¶æ¸…ç†æµç¨‹ä¸ºæ¯éš”ä¸€å®šçš„æ—¶é—´è°ƒç”¨ä¸€æ¬¡æ¸…ç†ï¼Œå…ˆè·å–ä¸€æ¬¡è¿‡æœŸçš„worker,å†å°†å…¶é‡Šæ”¾æ‰ï¼Œå› ä¸ºæ¯ä¸ªworkeréƒ½åœ¨ç­‰å¾…taskç®¡é“ï¼Œæ•…å¯é€šè¿‡ä¼ å…¥nilé€€å‡ºï¼Œè¯¦ç»†å¯è§worker.go 64è¡Œé™„è¿‘ã€‚åŒæ—¶ï¼Œåº”ä¸ºw.taskå¯èƒ½æ­£åœ¨é˜»å¡ï¼Œä¼šå¯¼è‡´`expiredWorkers[i].task <- nil`ä¹Ÿå µå¡ï¼Œè¿™å°±ä¼šå¯¼è‡´é”é•¿æ—¶é—´å¾—ä¸åˆ°é‡Šæ”¾ï¼Œä¼šæå¤§çš„å½±å“æ€§èƒ½ï¼Œæ•…åº”åœ¨é”å¤–è¿›è¡Œé€šçŸ¥wokeråœæ­¢ã€‚

##### retrieveWorker è¿”å›ä¸€ä¸ªå¯ç”¨çš„å·¥ä½œç¨‹åºæ¥è¿è¡Œä»»åŠ¡

åœ¨çœ‹submitå‰å¿…é¡»å…ˆäº†è§£retrieveWorker

```
// retrieveWorker returns a available worker to run the tasks.
func (p *Pool) retrieveWorker() (w *goWorker) {
	// å®šä¹‰ä¸€ä¸ªå–workerçš„å‡½æ•°å…¶æ˜¯åœ¨ç¼“å­˜ä¸­æ‹¿
	spawnWorker := func() {
		// è·å¾—ä¸€ä¸ªworkerå¯¹è±¡
		w = p.workerCache.Get().(*goWorker)
		// å¼€å§‹run,ç­‰å¾…ä»»åŠ¡çš„åˆ†é…
		w.run()
	}

	p.lock.Lock()
	// ä»é˜Ÿåˆ—ä¸­æ‹¿å‡ºä¸€ä¸ªworker
	w = p.workers.detach()
	if w != nil {
		// å¦‚æœæ‹¿åˆ°äº†ï¼Œç›´æ¥é€€å‡ºå°±æ˜¯äº†
		p.lock.Unlock()
	} else if capacity := p.Cap(); capacity == -1 {
		// å¦‚æœå®¹é‡ä¸è®¾ä¸Šé™ ç›´æ¥ä»ç¼“å­˜ä¸­æ‹¿
		p.lock.Unlock()
		spawnWorker()
	} else if p.Running() < capacity {
		p.lock.Unlock()
		// å¦‚æœæ²¡åˆ°å®¹é‡ä¸Šé™ ç›´æ¥ä»ç¼“å­˜ä¸­æ‹¿
		spawnWorker()
	} else {
		if p.options.Nonblocking {
			// å¦‚æœæ˜¯ä¸é˜»å¡çš„ï¼Œä¸æ‰§è¡Œä»»åŠ¡è¿”å›nil
			p.lock.Unlock()
			return
		}
	Reentry:
		if p.options.MaxBlockingTasks != 0 && p.blockingNum >= p.options.MaxBlockingTasks {
			// å¦‚æœé˜»å¡ä»»åŠ¡è¿‡å¤šä¹Ÿè¿”å›ç©º
			p.lock.Unlock()
			return
		}
		p.blockingNum++
		// ç­‰å¾…è¢«å”¤é†’
		p.cond.Wait()
		p.blockingNum--
		// å› ä¸ºå¦‚æœrunning()==0 è‚¯å®šp.workers.detach()æ˜¯æ‹¿ä¸åˆ°çš„æ•…åœ¨æ± å­é‡Œæ‹¿ä¸€ä¸ª
		// é¢˜é—®ï¼šä¸ºä»€ä¹ˆä¸æ˜¯p.Running()<capacityï¼Ÿ
		if p.Running() == 0 {
			p.lock.Unlock()
			spawnWorker()
			return
		}

		w = p.workers.detach()
		if w == nil {
			// åå¤å»æ‹¿åˆ°ä¸€ä¸ªworkerå»æ‰§è¡Œ
			goto Reentry
		}

		p.lock.Unlock()
	}
	return
}
```

åœ¨`retrieveWorker`ä¸­ä¸»è¦ç”¨äºè·å–ä¸€ä¸ªworkerå»æ‰§è¡Œä»»åŠ¡ï¼ŒåŒæ—¶æ ¹æ®ç”¨æˆ·çš„é…ç½®å»é™åˆ¶è·å–ã€‚åœ¨å¹¶å‘æ¡ä»¶ä¸‹é”çš„ä½ç½®å¾ˆé‡è¦ï¼Œé”ä¼šå¸¦æ¥å®‰å…¨ä½†ä¹Ÿä¼šé™ä½æ€§èƒ½ã€‚

##### Submit æäº¤ä»»åŠ¡

```
// Submit submits a task to this pool.
func (p *Pool) Submit(task func()) error {
	if atomic.LoadInt32(&p.state) == CLOSED {
		return ErrPoolClosed
	}
	var w *goWorker
	// è·å¾—ä¸€ä¸ªå¯ç”¨çš„worker å°†ä»»åŠ¡å‘é€ç»™workerå»æ‰§è¡Œ
	if w = p.retrieveWorker(); w == nil {
		return ErrPoolOverload
	}
	// ç›´æ¥é€šçŸ¥æ‰§è¡Œ
	w.task <- task
	return nil
}
```

##### revertWorker å°†ä¸€ä¸ªworkerç©ºé—²é˜Ÿåˆ—

```
// revertWorkerå°†å·¥ä½œäººå‘˜æ”¾å›ç©ºé—²æ± ï¼Œä»è€Œå›æ”¶goroutineã€‚
func (p *Pool) revertWorker(worker *goWorker) bool {
	if capacity := p.Cap(); (capacity > 0 && p.Running() > capacity) || atomic.LoadInt32(&p.state) == CLOSED {
		return false
	}
	// æ›´æ–°workerçš„æœ€åæ´»åŠ¨çš„æ—¶é—´
	worker.recycleTime = time.Now()

	// å› ä¸ºè¦å¯¹Workeré˜Ÿåˆ—è¿›è¡Œæ“ä½œï¼Œä¸Šé”ä¿è¯å¹¶å‘å®‰å…¨
	p.lock.Lock()

	// To avoid memory leaks, add a double check in the lock scope.
	// ä¸ºé¿å…å†…å­˜æ³„æ¼ï¼Œè¯·åœ¨é”å®šèŒƒå›´å†…è¿›è¡Œä»”ç»†æ£€æŸ¥ã€‚
	// Issue: https://github.com/panjf2000/ants/issues/113
	if atomic.LoadInt32(&p.state) == CLOSED {
		p.lock.Unlock()
		return false
	}
	// æ’å…¥æ“ä½œå…·ä½“ç”±`workerArrayå®ç°
	err := p.workers.insert(worker)
	if err != nil {
		p.lock.Unlock()
		return false
	}

	// Notify the invoker stuck in 'retrieveWorker()' of there is an available worker in the worker queue.
	p.cond.Signal()
	p.lock.Unlock()
	return true
}
```

æ­¤æ–¹æ³•åœ¨`goWoker.run()`ä¸­ä½¿ç”¨ï¼Œæ¯æ¬¡æ‰§è¡Œå®Œä»»åŠ¡éƒ½ä¼šå°†å…¶ä¸¢åˆ°é˜Ÿåˆ—æœ«å°¾ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡è°ƒåº¦ï¼ŒåŒæ—¶æ›´æ–°`recycleTime`ä¾¿äºæ¸…ç†æ— ç”¨worker ,åŒæ—¶è°ƒç”¨`p.cond.Signal()`é€šçŸ¥é˜»å¡ä»»åŠ¡å¯ä»¥è¿›è¡Œè°ƒåº¦äº†ã€‚ï¼ˆ`cond`å¥½åƒå¹¶ä¸æ˜¯Wait(),å’ŒSignal()ä¸€ä¸€å¯¹åº”çš„ï¼ŒæŒ‰ç…§è¿™ä¸ªä»£ç ï¼ŒSignal()è°ƒç”¨æ¬¡æ•°æ˜¯è¿œå¤§äºWait()çš„ï¼‰

##### Running è¿”å›æ­£åœ¨æ‰§è¡Œçš„worker

##### Free è¿”å›ç©ºé—²çš„worker

##### Cap è¿”å›å®¹é‡

##### Tune è°ƒæ•´æ± çš„å®¹é‡

##### Release å…³é—­pool

 é€šè¿‡è°ƒç”¨`workerArray.reset()`è¿›è¡Œæ¸…ç©ºworkersæ¥å®ç°workerçš„å…³é—­ï¼ŒåŒæ—¶æ ‡è®°`pool`çš„çŠ¶æ€ä¸º`CLOSED`

##### Reboot é‡å¯pool  (ps:æ„Ÿè§‰å¦‚æœåå¤å¼€å…³poolä¼šå¯¼è‡´æœ‰å¤šä¸ªæ¸…ç†å‡½æ•°æ‰§è¡Œå•ŠğŸ¤£ï¼‰

##### incRunning running++ 

è¿™ä¸ªæ“ä½œåˆ©ç”¨`atomic`åŒ…è¿›è¡Œæ“ä½œï¼Œä¿è¯å¹¶å‘æ¡ä»¶ä¸‹æ•°æ®çš„å‡†ç¡®æ€§ï¼Œä¸‹åŒã€‚

##### decRunning running--

#### worker

workerçš„ç»“æ„

```go
type goWorker struct {
	// pool who owns this worker.
	// è¿™ä¸ªworkerçš„ä¸»äººğŸ¤£
	pool *Pool

	// ä»»åŠ¡ç®¡é“
	task chan func()

	//workeré‡æ–°æ”¾å…¥é˜Ÿåˆ—æ—¶ï¼ŒrecycleTimeå°†è¢«æ›´æ–°ã€‚
	recycleTime time.Time
}
```

ç»“æ„å¾ˆç®€å•ï¼Œä¸»è¦ä¸€ä¸ªå°±æ˜¯ç”¨äºè¿›ç¨‹é€šä¿¡çš„chan

##### run è¿è¡Œ

```
func (w *goWorker) run() {
	// è®¡æ•°å™¨åŠ ä¸€
	w.pool.incRunning()
	// å¼€å¯ä¸€ä¸ªgoroutineè¿è¡Œä»»åŠ¡
	go func() {
		// ææ„å‡½æ•°
		defer func() {
			// è®¡æ•°å™¨--
			w.pool.decRunning()
			// å°†æ— ç”¨çš„workeræ”¾å…¥ç¼“å­˜æ± 
			w.pool.workerCache.Put(w)
			// å¤„ç†ç¨‹åºå‡ºç°çš„panic
			if p := recover(); p != nil {
				if ph := w.pool.options.PanicHandler; ph != nil {
					ph(p)
				} else {
					w.pool.options.Logger.Printf("worker exits from a panic: %v\n", p)
					var buf [4096]byte
					n := runtime.Stack(buf[:], false)
					w.pool.options.Logger.Printf("worker exits from panic: %s\n", string(buf[:n]))
				}
			}
		}()
		// ç­‰å¾…chanå‘é€ä»»åŠ¡
		for f := range w.task {
			// nilä¸»è¦ç”±purgePeriodically()å‘é€ï¼Œé€šçŸ¥workerå¯ä»¥å…³é—­äº†ã€‚
			if f == nil {
				return
			}
			// æ‰§è¡Œä»»åŠ¡
			f()
			// æ‰§è¡Œå®Œæ¯•ï¼Œå°†workeråŠ å…¥`workerArray`çš„ç©ºé—²é˜Ÿåˆ—ï¼Œå¦‚æœåŠ å…¥å¤±è´¥åˆ™é€€å‡ºï¼Œé¿å…é€ æˆå†…å­˜æ³„éœ²
			if ok := w.pool.revertWorker(w); !ok {
				return
			}
		}
	}()
}

```

å…¶`runå‡½æ•°`ç»´æŠ¤äº†`pool`çš„`Running`,åŒæ—¶ä¹Ÿè€ƒè™‘åˆ°äº†`panic`çš„å‘ç”Ÿï¼ˆpanicå¦‚æœä¸å¤„ç†æ˜¯ä¼šå¯¼è‡´ç¨‹åºç›´æ¥æŒ‚æ‰ï¼Œå°å¿ƒgoroutineï¼‰,åŒæ—¶ï¼Œæ¯æ¬¡æ‰§è¡Œå®Œæ¯•å°†workeråŠ å…¥`workerArray`çš„ç©ºé—²é˜Ÿåˆ—ï¼Œè¿™æ ·å°±å°†workerç®¡ç†èµ·æ¥äº†ã€‚

å¦‚å›¾ worker çš„æµç¨‹

![image-20210314001412616](/assets/image-20210314001412616.png)

#### workerArray

workerArray æ˜¯ä¸€ä¸ªæ¥å£ ä¸€äº›æ–¹æ³•ä¸Šæ–‡ä¸­å·²å¤šæ¬¡æåˆ°ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼Œä½œè€…è‡ªå·±ç”¨åˆ‡ç‰‡å®ç°äº†å¾ªç¯é˜Ÿåˆ—å’Œæ ˆä¸¤ç§ï¼Œå¾ˆå€¼å¾—å­¦ä¹ ã€‚

```
type workerArray interface {
	// è·å–ç©ºé—²é˜Ÿåˆ—çš„é•¿åº¦
	len() int
	// æ˜¯å¦æ˜¯ç©ºçš„
	isEmpty() bool
	// å°¾æ’ä¸€ä¸ªworker
	insert(worker *goWorker) error
	// è·å–ä¸€ä¸ªworker è·å–å¤±è´¥åˆ™è¿”å›nil
	detach() *goWorker
	// è·å–è¿‡æœŸçš„workeré˜Ÿåˆ—,åœ¨purgePeriodically()è°ƒç”¨
	retrieveExpiry(duration time.Duration) []*goWorker
	// åœæ­¢worker(æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ä¸ä¼šåœæ­¢ï¼Œåªæ˜¯å½“ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ä¸å†æ¥å—ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼Œä¼šé€€å‡º),æ¸…ç©ºworkerArray
	reset()
}
```

`worker_loop_queue` å’Œ `worker_stack`å®ç°äº†è¿™äº›æ–¹æ³•ï¼Œæ˜¯å¾ˆåŸºæœ¬çš„æ•°æ®ç»“æ„ï¼Œä½†æ˜¯ç”±ä¸‰ç‚¹å€¼å¾—æ³¨æ„

- è¿™ä¸æ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨è¿™äº›æ–¹æ³•çš„æ—¶å€™è¦ä¸Šé”ã€‚
- `worker_loop_queue` çš„å¤§å°æ˜¯ç¡®å®šçš„ï¼Œå¦‚æœçŸ­æ—¶é—´è¦æ‰§è¡Œçš„ä»»åŠ¡å¤ªå¤šï¼Œä¼šè¢«å µå¡æˆ–è€…è¿”å›nil
- `items  []*goWorker`  åœ¨itemsä¸­çš„éƒ½æ˜¯ç©ºé—²çš„ worker,`expiry []*goWorker` ä¸­ä¸ä¿å­˜æ•°æ®ï¼Œåªæ˜¯ä¸€ä¸ªç”¨æ¥ä¸´æ—¶è¿”å›è¿‡æœŸworkerçš„åˆ‡ç‰‡ï¼Œä¸ºé¿å…é¢‘ç¹åˆ›å»ºåˆ‡ç‰‡ã€‚

## ğŸ¤”æ€»ç»“

æœ‰å¿…è¦è®²ä¸€ä¸‹workersçš„è®¾è®¡ï¼Œæ¯ä¸€ä¸ªworkeréƒ½åœ¨run(),run()ä»£è¡¨å…¶æ­£åˆ™æ‰§è¡Œä»»åŠ¡æˆ–è€…æ­£åœ¨ç›‘å¬ç­‰å¾…ä»»åŠ¡ï¼Œworkerçš„åˆ›å»ºå’Œåˆ é™¤æ˜¯ä¾èµ–äº`sync.Pool`çš„ï¼Œå½“éœ€è¦ä¸€ä¸ªworkerï¼Œå°±åœ¨workersé˜Ÿåˆ—ä¸­æ‹¿ï¼Œæ‹¿ä¸åˆ°å°±ä»`sync.Pool`ä¸­æ‹¿ï¼Œæ¯åœæ­¢ä¸€ä¸ªworkerå°±æ”¾ä¸€ä¸ªworkerå›å»ï¼Œsync.Poolè¢«å®˜æ–¹è®¾è®¡ä¸ºä¸€ä¸ªé«˜æ€§èƒ½çš„å¤ç”¨ç¼“å­˜æ± ,æœ‰æ•ˆçš„é¿å…äº†åå¤è¿›è¡Œworkerå¯¹è±¡çš„åˆ›å»ºå’Œåˆ é™¤ã€‚

è¿˜æœ‰`sync.Cond`çš„ä½¿ç”¨ï¼Œå‡è®¾ä¸ä½¿ç”¨cond,æ–°ä»»åŠ¡å¦‚æœè¢«é˜»å¡äº†ï¼Œä¸€èˆ¬éƒ½æ˜¯ç”¨ä¸€ä¸ªrangeä¸€ä¸ªchan æŠ¢å å¼åœ°å»è·å–ä¸€ä¸ªworkerå»æ‰§è¡Œï¼Œå½“è¿‡å¤šçš„ä»»åŠ¡å»æŠ¢å ä¸€ä¸ªworkerï¼Œä¼šæµªè´¹cpuçš„æ€§èƒ½ã€‚å…¶é€šè¿‡condå”¤é†’ä¸€ä¸ªæˆ–è€…å¤šä¸ªå»æŠ¢å worker,å‡å°‘æ€§èƒ½æŸè€—ã€‚

`atomic` ,ç”¨æ¥ä¿è¯æ•°æ®çš„åŸå­æ“ä½œï¼Œåœ¨antsä¸­ç»å¸¸å¯ä»¥çœ‹åˆ°è¿™ä¸ªåº“çš„ä½¿ç”¨ï¼Œå› ä¸ºantsæ˜¯è®¾è®¡ä¸ºåœ¨é«˜å¹¶å‘æƒ…å†µä¸‹çš„è°ƒåº¦ç¨‹åºï¼Œæ•°æ®çš„åŸå­æ“ä½œå¾ˆé‡è¦ï¼ŒåŒæ—¶ï¼Œantsä¸­çš„è‡ªæ—‹é”ä¹Ÿæ˜¯åŸºäºæ­¤æ¥å®ç°çš„ã€‚

ç³»ç»Ÿä¸­ä¼˜è‰¯çš„æ¥å£è®¾è®¡ï¼Œå¥½çš„æ¥å£è®¾è®¡å¯ä»¥å¾ˆæ˜ç¡®ç³»ç»Ÿçš„åŠŸèƒ½ï¼ŒåŒæ—¶ä¹Ÿåˆ©äºä»£ç çš„ä¿®æ”¹å’Œè§£è€¦ã€‚è¿™æ˜¯å¾ˆå€¼å¾—å»å­¦ä¹ çš„ã€‚



export default ({ children }) => <Layout meta={meta}>{children}</Layout>
